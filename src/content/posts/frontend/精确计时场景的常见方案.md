---
title: 精确计时场景的常见方案
published: 2025-08-07
description: 精确计时场景下的一些方案参考
image: https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/bg-js.png
tags: []
category: 前端
draft: false 
---

## 一些需要精确计时的场景

:::note
* 在线游戏
* 金融交易系统
* 多媒体应用
* 工业控制
* 实时监控平台
* ... ...
:::

## 常见方案

### 1. 服务端主导的时间同步

:::tip[优 势]

* 误差可控制在 10-50ms 内
* 避免客户端时间篡改
* 支持多设备同步

:::

![时间同步示意图](https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E5%AF%BC%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5.png)

简单示例：
```js
// 客户端
async function syncTime() {
  const start = Date.now();
  const response = await fetch('/api/sync-time');
  const end = Date.now();
  
  const { serverTime } = await response.json();
  const networkDelay = (end - start) / 2;
  
  // 校正客户端时间
  const correctedTime = serverTime + networkDelay;
  return correctedTime;
}

// 服务端 (Node.js)
app.get('/api/sync-time', (req, res) => {
  res.json({ serverTime: Date.now() });
});
```

### 2.WebSocket 实时时序控制
:::tip[适 用 场 景]
* 多人在线游戏、实时协作工具

:::

服务端示例：
```js
// 服务端广播时序指令
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

setInterval(() => {
  const timestamp = Date.now();
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({
        type: 'SYNC_TIMER',
        payload: timestamp
      }));
    }
  });
}, 100); // 每100ms广播一次
```
客户端示例：
```js
const ws = new WebSocket('ws://server-address');
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === 'SYNC_TIMER') {
    // 执行需要精确时间的操作
    renderFrame(data.payload);
  }
};
```

### 3. Web Workers + 高精度 API
:::tip
关键API：
* performance.now()：微秒级精度（不受系统时间影响）
* performance.timeOrigin：页面加载起始时间点

:::

简单示例：
```js
// 在 Web Worker 中执行精确计时
// timer.worker.js
let startTime;
self.onmessage = (e) => {
  if (e.data.command === 'start') {
    startTime = performance.now();
    setInterval(() => {
      const elapsed = performance.now() - startTime;
      self.postMessage({ elapsed });
    }, e.data.interval);
  }
};

// 主线程
const worker = new Worker('timer.worker.js');
worker.postMessage({ command: 'start', interval: 10 });
worker.onmessage = (e) => {
  console.log(`精确耗时: ${e.data.elapsed.toFixed(3)}ms`);
};

```
## 总结

### 1.分层控制策略

| 精度要求 | 解决方案                          |
| -------- | --------------------------------- |
| 1ms+     | Web Workers + `performance.now()` |
| 10ms+    | 服务端时间同步                    |
| 100ms+   | 原生 `setTimeout`                 |

### 2.黄金法则
:::warning
* 关键时间判断必须在服务端执行
* 客户端只做可视化展示
* 所有时间敏感操作附带时间戳
* 使用 ISO 8601 格式传输时间

:::