---
title: PNPM内部机制解析
published: 2026-01-09
description: '本文介绍了PNPM的主要优势和内部机制，帮助读者理解PNPM的工作原理'
image: 'https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.png'
tags: [PNPM]
category: 前端
draft: false 
---

## `PNPM`核心优势

### 极致的磁盘空间利用率：一份依赖多项目共享

> ​		所有项目共用一个全局依赖库，相同版本的依赖仅在全局存储中存储一次，各项目通过链接的方式引用，而非复制一份到本地`node_modules`。
>
> ​		*根据官方数据，`PNPM`的磁盘占用较`npm`和`yarn`降低70%以上。*

### 更快的安装速度：超越`Yarn`的效率提升

> ​		`PNPM`延续了`Yarn`的并行下载优势，并且通过链接复用减少了I/O操作，依赖下载完成后，无需将依赖复制到项目目录，只需创建链接，操作耗时大幅降低。
>
> ​		*根据官方测试数据，`PNPM`的安装速度较`NPM`快2~3倍；较`YARN`快1.5倍左右。*

### 严谨的依赖管理: 杜绝幽灵依赖

> ​		`PNPM`采用了**“非扁平化”**的依赖树结构，通过嵌套+软链接从根源上杜绝了幽灵依赖。

### 原生强支持`Monorepo`

> ​		通过`pnpm-worksapce.yaml`配置文件，可以轻松开始多包昔日通过开发，还提供了如`pnpm run -r`等命令，支持批量执行子包脚本。

## `PNPM`内部机制

> **从“复制”到“链接”的革命**：
>
> *传统包管理器（npm/Yarn）的安装逻辑是“下载-复制”：先将依赖从npm仓库下载到本地缓存，再将缓存中的依赖复制到项目的node_modules目录。而PNPM的核心逻辑是“下载-链接”：依赖下载到全局存储后，通过硬链接和软链接将依赖关联到项目的node_modules目录，无需复制*

### 内容寻址存储(CAS)

:::note

* 核心逻辑：**基于文件内容生成唯一标识**。PNPM会对每个下载的依赖文件进行哈希计算（如SHA-512），生成唯一的哈希值，该哈希值将作为依赖的“身份证”，**用于索引和存储依赖**。
* 优点：
  * **减少重复存储**：不同版本的依赖如果包含相同的文件（如lodash的多个版本可能共享部分核心文件），这些文件会被多次引用但仅存储一次；
  * **确保依赖完整性**：哈希值可以验证依赖文件是否被篡改，提升了依赖的安全性；

:::

PNPM全局存储(默认~/.pnpm-store/v3/files) 结构示例：

```
~/.pnpm-store/
└── v3/
    └── files/
        ├── 0f/          # 哈希前缀（取前两位）
        │   └── 0f8f9e78  # 完整哈希文件名，内容是 fr@1 的 index.js
        ├── 1a/
        │   └── 1a9f0b87  # 内容是 fr@1 的 debug.js
        └── 2c/
            └── 2c7d1c65  # 内容是 fr@1 的 package.json
```

### [硬链接](https://zh.wikipedia.org/wiki/%E7%A1%AC%E9%93%BE%E6%8E%A5)：依赖内容的共享访问

:::note

- **在PNPM中，项目的直接依赖会通过硬链接关联到全局存储中的依赖文件**。*例如，项目A的node_modules/react中的文件，实际上是~/.pnpm-store中react对应文件的硬链接。这种方式确保了多个项目可以共享同一份依赖内容，且不会占用额外的磁盘空间。*

:::

### [软链接](https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5)：构建清晰的依赖树结构

:::note

- **PNPM利用软链接构建间接依赖树。** 在非扁平化的依赖结构中，间接依赖会被存储在直接依赖的node_modules中，但为了避免依赖的深层嵌套和重复存储，PNPM会通过软链接将间接依赖指向全局存储或其他依赖的node_modules。

:::

### 依赖的安装流程

![PNPM安装依赖流程](https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/pnpm_install_workflow.png)

## Q & A

### PNPM 的 CAS 仓库和 npm/yarn 的缓存目录有本质区别吗？

> | 维度         | npm/yarn 缓存目录                                            | PNPM CAS 仓库                                                |
> | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | **寻址方式** | 版本寻址：`包名@版本`（如 `lodash@4.17.21`）                 | 内容寻址：`文件内容哈希`（如 `0f8f9e78`）                    |
> | **存储单元** | 完整的依赖包（.tgz 压缩包或解压后的完整目录）                | 单个文件（按哈希拆分存储）                                   |
> | **复用逻辑** | 仅避免重复下载：同一版本包下载一次，不同项目安装时仍会复制到各自 `node_modules` | 避免重复存储：同一内容的文件仅存一份，所有项目通过硬链接复用 |
> | **冗余性**   | 高：多个项目安装同一版本包，磁盘仍存多份完整包（缓存是一份，项目里是多份） | 极低：多个项目共享同一哈希文件，磁盘仅存一份文件内容         |
> | **隔离性**   | 无：缓存的完整包无法隔离多版本子依赖                         | 强：哈希唯一标识内容，多版本依赖通过哈希隔离                 |
> | **存储结构** | 按「包名 / 版本」层级（如 `~/.npm/_cacache/lodash/4.17.21`） | 按「哈希前缀 / 完整哈希」层级（如 `~/.pnpm-store/v3/files/0f/0f8f9e78`） |
> | **修改影响** | 修改项目 `node_modules` 文件，不影响缓存                     | 修改项目硬链接文件，触发写时复制，不影响 CAS 仓库            |

### PNPM为什么不用软链接直接指向全局存储？

> 「硬链接 + 软链接 + 虚拟目录」的组合，是在「磁盘效率」「依赖隔离」「运行稳定性」之间的最优解。软链接的特性无法适配依赖管理的全部需求，全软链接会导致依赖隔离性、稳定性、兼容性崩塌：
>
> * **依赖隔离性完全丧失(多版本冲突)**：
>   * 场景：项目依赖 `axios@1`（依赖 `follow-redirects@1`）和 `request@2`（依赖 `follow-redirects@2`）
>   * 如果全软链接指向全局存储：`axios` 和 `request` 都需要访问 `follow-redirects`，但全局存储中 `follow-redirects@1` 和 `@2` 是两个目录；而软链接只能指向「一个固定路径」，无法让 `axios` 看到 `@1`、`request` 看到 `@2`—— 最终必然导致其中一个依赖的子依赖版本错误，程序崩溃
>   * PNPM的方案：
>     * 先通过 `.pnpm` 虚拟目录为每个依赖包构建「独立的依赖树」（`axios@1` 的子依赖在 `.pnpm/axios@1/node_modules`，`request@2` 的在 `.pnpm/request@2/node_modules`）；
>     * 再用硬链接将全局存储的文件指向这些独立目录中的文件 —— 既复用了内容，又保证了每个包的依赖树隔离。
> * **稳定性差**：软链接的本质是”路径的快捷方式”，所以任何可能导致依赖路径发生变化的操作都会导致链接失效
> * **性能问题**: 由于全局 CAS 仓库中存储的是「按哈希拆分的文件」，而非「完整的依赖目录结构，所以如果强行要让软链接指向完整的依赖目录，pnpm就要改变原先的存储结构，失去了内容复用的核心价值，同时全局存储的体积也会暴增
> * **无法处理「修改依赖文件」的场景**(开发中偶尔会需要临时修改 node_modules 中的依赖文件, 比如调试源码)：
>   * 如果是软链接指向全局存储，修改项目中 `node_modules` 里的文件，会直接修改全局存储中的文件 —— 所有其他项目的该依赖都会被篡改，引发不可预知的问题
>   * 如果是硬链接，修改项目中的文件，只会修改「该硬链接指向的 inode 内容」？不 —— 实际是：硬链接指向的是全局存储的文件副本（inode），修改项目中的硬链接文件，会自动「复制写（Copy-on-Write）」，生成新的 inode，不会影响全局存储和其他项目

### PNPM如何支持跨磁盘/文件系统？

> * **策略1：检测硬链接可用性，自动降级为复制**
>
>   * ![pnpm跨文件系统适配策略-自动降级](https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/pnpm%E8%B7%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AD%96%E7%95%A5.png)
>
> * **策略2：软链接不受文件系统限制，全程可用**
>
> * **策略3：支持自定义CAS仓库路径**
>
>   * 全局配置：
>
>     * ```bash
>       # 将全局 CAS 仓库设置为 D 盘（Windows）
>       pnpm config set store-dir D:\.pnpm-store
>         
>       # 将全局 CAS 仓库设置为 /mnt/nfs（Linux/macOS）
>       pnpm config set store-dir /mnt/nfs/.pnpm-store
>       ```
>
>   * 项目级配置：为单个项目指定CAS仓库
>
>     * ```bash
>       # .npmrc
>       store-dir = ./pnpm-store  # 仓库放在项目目录下（和项目同文件系统）
>       # 或指定到其他磁盘
>       store-dir = D:\pnpm-store-for-this-project
>       ```
>
>   * 临时指定：单次安装时指定仓库
>
>     * ```bash
>       pnpm install --store-dir D:\temp-pnpm-store
>       ```
>
> * **策略4：对网络文件系统(NFS/SMB)的适配**：
>
>   * 当项目或 CAS 仓库部署在网络文件系统（如 NFS、SMB 共享盘）时：
>     * npm 会优先尝试创建「符号链接（Symlink）」而非「硬链接」（因为网络文件系统通常禁用硬链接）；
>     * 若符号链接也不可用（如部分老旧 NFS 版本），则直接复制文件；
>     * 同时，pnpm 会优化文件操作（减少频繁的文件系统读写），降低网络延迟的影响

### PNPM 的 `.pnpm` 虚拟目录是必须的吗？删除后会影响项目运行吗？

> `.pnpm`目录是PNPM依赖管理的核心载体，不可缺少，删除后项目无法运行。该目录的核心作用：
>
> - **存储所有依赖的“隔离依赖树”**
>
>   - ```
>     .pnpm/
>     ├── axios@1.6.0/
>     │   └── node_modules/
>     │       ├── axios/  # axios 本体（硬链接指向 CAS 仓库）
>     │       └── follow-redirects/  # axios 的子依赖（仅 axios 可访问）
>     └── react@18.2.0/
>         └── node_modules/
>             └── react/  # react 本体
>     ```
>
> - **实现"依赖隔离"的核心**
>
> - **管理依赖的元数据**：.pnpm目录中还存储了依赖的元数据(如[文件-哈希]清单、依赖树解析结果、peer依赖映射)

### PNPM store prune 清理仓库时，如何保证正在使用的依赖不被误删？

> 核心逻辑：**[硬链接引用计数] + [项目依赖清单扫描]** 的双重校验，只删除无**任何项目引用**的哈希文件，确保正在使用的依赖绝对安全。

### 多团队协作时，不同开发者的 CAS 仓库路径不同，会导致依赖安装结果不一致吗？

> 不会，因为PNPM的依赖解析、安装逻辑是**[基于内容哈希而非路径]**的，路径不会影响依赖树机构和文件内容

### PNPM 处理 peer 依赖时，如何保证多个子包共享同一版本且不冲突？

> 传统包管理器(npm/yarn)的痛点：
>
> - 若多个子包要求的peer依赖版本范围不兼容，如 `antd@5` 要求 `react@>=18`，`old-plugin` 要求 `react@^17`），会直接报错
> - 若版本范围兼容，npm/yarn 会随机提升一个版本，可能导致隐式冲突；
>
> PNPM处理peer依赖的四层核心机制：
>
> - **机制1：前置版本解析+自动协商兼容版本**：
>
>   - 1.扫描收集：比哪里所有直接依赖/子依赖的package.json，手机所有peer依赖的版本要求
>   - 2.版本协商：通过语义化版本(semver)规则，计算出满足所有要求的最优兼容版本
>   - 3.冲突报错：若版本要求无法兼容（如同时要求 `react@>=18` 和 `react@<=17`），PNPM会显式报错，而非静默忽略，强制开发者解决版本冲突
>
> - **机制2：根目录提升+单一版本共享**：PNPM 会将协商后的兼容版本 peer 依赖**唯一一份**提升到项目根 `node_modules`，供所有子包共享
>
>   - ```
>     # PNPM 处理 react peer 依赖的结构
>     node_modules/
>     ├── react → .pnpm/react@18.2.0/node_modules/react  # 唯一的 react 软链接（根目录）
>     .pnpm/
>     ├── antd@5.12.0/
>     │   └── node_modules/
>     │       ├── antd/  # 硬链接
>     │       └── react → ../../../react@18.2.0/node_modules/react  # 软链接到根 react
>     ├── ahooks@3.7.8/
>     │   └── node_modules/
>     │       ├── ahooks/
>     │       └── react → ../../../react@18.2.0/node_modules/react  # 同一份 react
>     └── react@18.2.0/
>         └── node_modules/
>             └── react/  # react 实际文件（硬链接指向 CAS 仓库）
>     ```
>
> - **机制3：依赖树扁平化校验**：NPM 本身是「嵌套依赖树」设计，但为了适配 peer 依赖的「全局共享」要求，会做特殊的扁平化处理
>
> - **机制4：显式声明强制 + 锁文件固化**：PNPM 要求开发者**显式声明**项目的 peer 依赖（而非隐式提供），并通过锁文件固化版本
