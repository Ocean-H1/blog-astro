---
title: 常用设计模式概述
published: 2025-02-07
description: '一些常用设计模式的简单实现和应用场景'
image: https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/design-pattern.png
tags: []
category: 设计模式
draft: false 
---
:::note[前 言]
本文不会对设计模式理论和实现进行系统的介绍，篇幅重点在于应用场景的总结。  
如果有时间，推荐大家系统的对设计模式进行学习(无论是为了晋升、求职还是单纯想要提高自己的代码质量)，在文章末尾有个人推荐一些相关的文章和书籍。  
**本文适合人群？**
* 设计模式入门小白
* 不知道如何使用设计模式(应用场景)

**本文你能收获什么？**
* 一些常用的设计模式在日常开发中的应用场景和简单实现
:::

## 什么是设计模式？
> 官方一点的解释：*设计模式是经过验证的、可复用的解决方案，用于解决软件设计中的常见问题。*  
> 通俗点讲，设计模式就像游戏玩家的"攻略"或厨师的"菜谱"。在程序世界，编程的"套路"就是设计模式，即针对特定问题、场景的较优解决方案。
## 为什么需要设计模式？
> 引用鲁迅在《故乡》中的一句话：“其实地上本没有路，走的人多了，也便成了路”，设计模式便是前人总结出来的"路"。当遇到相似的问题或场景的时候，就能利用这些经验和套路更快给出更优的解决方案，也算是“踩在巨人的肩膀上前进”了
## 一些常用的设计模式：

### 策略模式(Strategy Pattern)
:::note[概 述]
* 定义：策略模式属于*行为型设计模式*，其通常定义了一系列算法(策略)，并且每个算法封装成独立的类，使它们可以想换替换。这样做，可以将算法(策略)的变化独立于客户端，从而可以便捷的动态切换算法，避免冗余的条件判断。
* 核心思想：**将做什么(目标)和怎样做(具体实现)分开**。
* 核心组成：
  * 策略接口（Strategy Interface）
    * 定义算法的公共策略
  * 具体策略类（Concrete Strategies）
    * 策略的具体算法实现
  * 上下文类（Context）
    * 持有一个策略对象的引用，通过策略接口调用具体算法(客户端代码与具体策略的桥梁角色)
* 例子：在使用导航的时候，你只需要提供你的出发地和目的地，而具体走哪条线路(高速优先、避开拥堵、最短距离等)由导航策略决定，变更线路的时候，只需要切换策略即可。
:::
#### 场景：电商促销折扣策略
> 假设一个电商平台需要支持多种促销折扣（无折扣、满减、打折），通过策略模式动态切换折扣策略。
```typescript
// 策略接口，定义折扣计算方法的规范
interface DiscountStrategy {
  calculate(price: number): number;
}

// 具体策略类: 实现不同的折扣算法
// 原价
class NoDiscount implements DiscountStrategy {
  calculate(price: number): number {
    return price;
  }
}
// 满减
class FullReduction implements DiscountStrategy {
  constructor(private threshold: number, private reduction: number) {}
  calculate(price: number): number {
    if (price >= this.threshold) {
      return price - this.reduction;
    }
    return price;
  }
}
// 打折
class PercentageDiscount implements DiscountStrategy {
  constructor(private percentage: number) {}
  calculate(price: number): number {
    return price * (1 - this.percentage / 100);
  }
}

// 上下文类
class ShoppingCart {
  private strategy: DiscountStrategy;
  constructor(strategy: DiscountStrategy = new NoDiscount()) {
    this.strategy = strategy;
  }

  setStrategy(strategy: DiscountStrategy) {
    this.strategy = strategy;
  }

  checkout(price: number): number {
    return this.strategy.calculate(price);
  }
}

// 使用示例:
const cart = new ShoppingCart();
// 默认无折扣
console.log(cart.checkout(100)); // 100
// 切换为满减策略(满200减50)
cart.setStrategy(new FullReduction(200, 50));
console.log(cart.checkout(300)); // 250
// 切换为打折策略(8折)
cart.setStrategy(new PercentageDiscount(20));
console.log(cart.checkout(300)); // 240
```

:::tip[使用场景]
可以看到上面的方式节省了大量的`if...else...`，还有一些其他适用场景比如：表单验证规则、权限校验、支付方式切换等等。  
当满足以下情况时，都可以考虑使用：
* 各判断条件下的策略相互独立并且可复用
* 策略内部逻辑相对复杂
* 策略需要灵活组合
:::

### 观察者模式


### 发布-订阅模式
:::note[概 述]
* 定义：
* 核心思想：
:::
### 装饰器模式

### 适配器模式

### 代理模式

### 责任链模式

### 单例模式

## 相关文章/资料：

* [掘金：前端中的设计模式](https://juejin.cn/post/6844904138707337229?searchId=20250120200113D96A3721A125A062D3FB#heading-8 "掘金")
* ::github{repo="Ocean-H1/design-pattern"}
* ::github{repo="me115/design_patterns"}
* ::github{repo="PDKSophia/DesignPatternsToJS"}
* 《图解设计模式》——【日】结城浩 人民邮电出版社
* 《大话设计模式》——程杰 清华大学出版社