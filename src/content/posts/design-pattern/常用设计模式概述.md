---
title: 常用设计模式概述
published: 2025-02-07
description: '一些常用设计模式的简单实现和应用场景'
image: https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/design-pattern.png
tags: []
category: 设计模式
draft: false 
---
:::note[前 言]
本文不会对设计模式理论和实现进行系统的介绍，篇幅重点在于应用场景的总结。  
如果有时间，推荐大家系统的对设计模式进行学习(无论是为了晋升、求职还是单纯想要提高自己的代码质量)，在文章末尾有个人推荐一些相关的文章和书籍。  
**本文适合人群？**
* 设计模式入门小白
* 不知道如何使用设计模式(应用场景)

**本文你能收获什么？**
* 一些常用的设计模式在日常开发中的应用场景和简单实现
:::

## 什么是设计模式？
> 官方一点的解释：*设计模式是经过验证的、可复用的解决方案，用于解决软件设计中的常见问题。*  
> 通俗点讲，设计模式就像游戏玩家的"攻略"或厨师的"菜谱"。在程序世界，编程的"套路"就是设计模式，即针对特定问题、场景的较优解决方案。
## 为什么需要设计模式？
> 引用鲁迅在《故乡》中的一句话：“其实地上本没有路，走的人多了，也便成了路”，设计模式便是前人总结出来的"路"。当遇到相似的问题或场景的时候，就能利用这些经验和套路更快给出更优的解决方案，也算是“踩在巨人的肩膀上前进”了
## 一些常用的设计模式：

### 策略模式(Strategy Pattern)
:::note[概 述]
* 定义：策略模式属于*行为型设计模式*，其通常定义了一系列算法(策略)，并且每个算法封装成独立的类，使它们可以想换替换。这样做，可以将算法(策略)的变化独立于客户端，从而可以便捷的动态切换算法，避免冗余的条件判断。
* 核心思想：**将做什么(目标)和怎样做(具体实现)分开**。
* 核心组成：
  * 策略接口（Strategy Interface）
    * 定义算法的公共策略
  * 具体策略类（Concrete Strategies）
    * 策略的具体算法实现
  * 上下文类（Context）
    * 持有一个策略对象的引用，通过策略接口调用具体算法(客户端代码与具体策略的桥梁角色)
* 例子：在使用导航的时候，你只需要提供你的出发地和目的地，而具体走哪条线路(高速优先、避开拥堵、最短距离等)由导航策略决定，变更线路的时候，只需要切换策略即可。
:::
#### 场景：电商促销折扣策略
> 假设一个电商平台需要支持多种促销折扣（无折扣、满减、打折），通过策略模式动态切换折扣策略。
```typescript
// 策略接口，定义折扣计算方法的规范
interface DiscountStrategy {
  calculate(price: number): number;
}

// 具体策略类: 实现不同的折扣算法
// 原价
class NoDiscount implements DiscountStrategy {
  calculate(price: number): number {
    return price;
  }
}
// 满减
class FullReduction implements DiscountStrategy {
  constructor(private threshold: number, private reduction: number) {}
  calculate(price: number): number {
    if (price >= this.threshold) {
      return price - this.reduction;
    }
    return price;
  }
}
// 打折
class PercentageDiscount implements DiscountStrategy {
  constructor(private percentage: number) {}
  calculate(price: number): number {
    return price * (1 - this.percentage / 100);
  }
}

// 上下文类
class ShoppingCart {
  private strategy: DiscountStrategy;
  constructor(strategy: DiscountStrategy = new NoDiscount()) {
    this.strategy = strategy;
  }

  setStrategy(strategy: DiscountStrategy) {
    this.strategy = strategy;
  }

  checkout(price: number): number {
    return this.strategy.calculate(price);
  }
}

// 使用示例:
const cart = new ShoppingCart();
// 默认无折扣
console.log(cart.checkout(100)); // 100
// 切换为满减策略(满200减50)
cart.setStrategy(new FullReduction(200, 50));
console.log(cart.checkout(300)); // 250
// 切换为打折策略(8折)
cart.setStrategy(new PercentageDiscount(20));
console.log(cart.checkout(300)); // 240
```

:::tip[适用场景]
可以看到上面的方式节省了大量的`if...else...`，还有一些其他适用场景比如：表单验证规则、权限校验、支付方式切换等等。  
当满足以下情况时，都可以考虑使用：
* 各判断条件下的策略相互独立并且可复用
* 策略内部逻辑相对复杂
* 策略需要灵活组合
:::

### 发布-订阅模式
:::note[概 述]

* 定义：发布-订阅属于*行为型设计模式*，它定义了一种依赖关系：当一个对象（发布者）的状态发生改变时，所有依赖它的对象（订阅者）都会自动收到通知并执行相应操作。
* 核心特点：
  * 发布者和订阅者**完全解耦**，彼此不直接依赖
  * 通过事件通道传递消息
  * 支持动态添加和移除订阅者
* 核心组成：
  * 事件通道(Event Channel)
    * 维护订阅关系（事件类型与订阅者的映射）
    * 提供订阅（subscribe）、取消订阅（unsubscribe）和发布（publish）方法
  * 发布者(Publisher)
    * 触发事件，通过事件通道发布消息
  * 订阅者(Subscriber)
    * 事件通道注册回调函数，收到通知后执行操作
* 例子：
  * 微信公众号：
    * 发布者(公众号)：负责发布新文章
    * 订阅者(用户)：关注公众号后，新文章会自动推送。
    * 事件通道(微信平台)：负责管理订阅关系，将文章分发给所有订阅者。  

:::
#### 场景：实现一个事件总线
```typescript
type EventHandler = (...args: any[]) => void;

class EventBus {
  private events: Map<string, EventHandler[]> = new Map();

  // 订阅事件
  subscribe(eventName: string, handler: EventHandler): void {
    const handlers = this.events.get(eventName) || [];
    handlers.push(handler);
    this.events.set(eventName, handlers);
  }

  // 取消订阅
  unsubscribe(eventName: string, handler: EventHandler): void {
    const handlers = this.events.get(eventName);
    if (!handlers) return;
    const index = handlers.indexOf(handler);
    if (index > -1) {
      handlers.splice(index, 1);
    }
  }

  // 发布事件
  publish(eventName: string, ...args: any[]): void {
    const handlers = this.events.get(eventName);
    if (handlers) {
      handlers.forEach(handler => handler(...args));
    }
  }
}

// 使用示例
const eventBus = new EventBus();

// 订阅者A：监听登录事件
eventBus.subscribe('login', (user: string) => {
  console.log(`订阅者A：用户 ${user} 已登录`);
});

// 订阅者B：监听登录事件
const handlerB = (user: string) => {
  console.log(`订阅者B：欢迎 ${user}！`);
};
eventBus.subscribe('login', handlerB);

// 发布登录事件
eventBus.publish('login', '张三');
// 输出：
// 订阅者A：用户 张三 已登录
// 订阅者B：欢迎 张三！

// 取消订阅者B
eventBus.unsubscribe('login', handlerB);

// 再次发布事件
eventBus.publish('login', '李四');
// 输出：
// 订阅者A：用户 李四 已登录
```

:::tip[适用场景]

* 跨模块/组件通信：多个独立模块或组件需通信，但直接依赖会导致耦合
* 实时事件驱动系统（比如实时聊天系统）：需要实时响应异步事件并广播给多个消费者
* 日志和监控系统：多个子系统需要监听核心事件以记录日志或监控状态
* 插件化架构：允许第三方插件通过订阅事件扩展核心功能
* 批量任务处理：将任务分解为多个步骤，通过事件驱动异步处理
* ... ...

判断是否使用发布订阅模式的一些标准：
* **解耦需求**：系统需要减少模块间的直接依赖
* **多对多通信**：存在多个发布者和多个订阅者（如聊天室中所有用户既是发布者又是订阅者）
* **动态订阅关系**：订阅关系需在运行时动态调整（如用户自定义通知偏好）
* **异步处理**：事件处理可延迟或并行执行（如日志记录、非关键任务）
* **可扩展性需求**：未来可能新增事件类型或订阅者（如插件系统）

:::
### 观察者模式

### 装饰器模式

### 适配器模式

### 代理模式

### 责任链模式

### 单例模式

## 相关文章/资料：

* [掘金：前端中的设计模式](https://juejin.cn/post/6844904138707337229?searchId=20250120200113D96A3721A125A062D3FB#heading-8 "掘金")
* ::github{repo="Ocean-H1/design-pattern"}
* ::github{repo="me115/design_patterns"}
* ::github{repo="PDKSophia/DesignPatternsToJS"}
* 《图解设计模式》——【日】结城浩 人民邮电出版社
* 《大话设计模式》——程杰 清华大学出版社